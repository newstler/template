#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "yaml"
require "securerandom"

APP_ROOT = File.expand_path("..", __dir__)

# Install lipgloss if not available
begin
  require "lipgloss"
rescue LoadError
  puts "Installing lipgloss gem for terminal styling..."
  system("gem install lipgloss --no-document") || abort("Failed to install lipgloss gem")
  Gem.clear_paths
  require "lipgloss"
end

def system!(*args)
  system(*args, exception: true)
end

def project_name_from_directory
  File.basename(APP_ROOT)
end

# Converts to Ruby module name for config/application.rb
# "my_project" -> "MyProject", "template" -> "Template", "MyApp" -> "MyApp"
def to_class_name(string)
  return string if string.nil? || string.empty?
  return string.split(/[-_]/).map(&:capitalize).join if string.match?(/[-_]/)

  string[0].upcase + string[1..].to_s
end

# Converts to kebab-case for Docker service names, S3 buckets, etc.
# "ProjectName" -> "project-name"
def to_service_name(string)
  string.gsub(/([A-Z])/, '-\1').downcase.sub(/^-/, "").gsub(/[^a-z0-9-]/, "-")
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Styles
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VIOLET = "#7D56F4"
PURPLE = "#874BFD"
GREEN = "#04B575"
MUTED = "#626262"
WHITE = "#FAFAFA"
ORANGE = "#FF9F1C"
CYAN = "#00D9FF"
HOTPINK = "#FF1493"
GOLD = "#FFD700"
YELLOW = "#FFFF00"

HEADER_STYLE = Lipgloss::Style.new
  .border(:rounded)
  .border_foreground(VIOLET)
  .padding_top(1)
  .padding_bottom(1)
  .padding_left(4)
  .padding_right(4)
  .bold(true)
  .foreground(WHITE)

SECTION_STYLE = Lipgloss::Style.new
  .foreground(PURPLE)
  .bold(true)
  .margin_top(1)
  .margin_bottom(1)

SUCCESS_STYLE = Lipgloss::Style.new
  .foreground(GREEN)

MUTED_STYLE = Lipgloss::Style.new
  .foreground(MUTED)
  .italic(true)

SUMMARY_STYLE = Lipgloss::Style.new
  .border(:rounded)
  .border_foreground(GREEN)
  .padding_top(1)
  .padding_bottom(1)
  .padding_left(2)
  .padding_right(2)

WARNING_STYLE = Lipgloss::Style.new
  .foreground(ORANGE)
  .bold(true)

PROMPT_STYLE = Lipgloss::Style.new
  .foreground(CYAN)
  .bold(true)

DEFAULT_STYLE = Lipgloss::Style.new
  .foreground(MUTED)

INPUT_STYLE = Lipgloss::Style.new
  .foreground(GOLD)

TIP_STYLE = Lipgloss::Style.new
  .foreground(HOTPINK)
  .bold(true)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Output helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def header(text) = puts HEADER_STYLE.render(text)
def section(text) = puts SECTION_STYLE.render("â”€â”€ #{text} â”€â”€")
def success(text) = puts SUCCESS_STYLE.render(text)
def muted(text) = puts MUTED_STYLE.render(text)
def warning(text) = puts WARNING_STYLE.render(text)
def summary(text) = puts SUMMARY_STYLE.render(text)
def tip(text) = puts TIP_STYLE.render(text)

def replace_in_file(file_path, old_content, new_content)
  return unless File.exist?(file_path)

  content = File.read(file_path)
  if content.include?(old_content)
    File.write(file_path, content.gsub(old_content, new_content))
    success("  âœ“ Updated #{file_path}")
  end
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Prompts
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# ANSI escape codes for cursor control
CURSOR_UP = "\e[1A"
CLEAR_LINE = "\e[2K"
RESET_COLOR = "\e[0m"

# Convert hex color to ANSI true color escape sequence
def ansi_color(hex)
  hex = hex.delete("#")
  r = hex[0..1].to_i(16)
  g = hex[2..3].to_i(16)
  b = hex[4..5].to_i(16)
  "\e[38;2;#{r};#{g};#{b}m"
end

def prompt(question, default = nil)
  label = PROMPT_STYLE.render(question)
  colon = DEFAULT_STYLE.render(":")

  if default
    default_hint = DEFAULT_STYLE.render(" [#{default}]")
    print "#{label}#{default_hint}#{colon} #{ansi_color(YELLOW)}"
  else
    print "#{label}#{colon} #{ansi_color(YELLOW)}"
  end

  answer = $stdin.gets.chomp
  print RESET_COLOR
  result = answer.empty? && default ? default : answer

  # Rewrite the line with the final value
  print "#{CURSOR_UP}#{CLEAR_LINE}"
  puts "#{label}#{colon} #{INPUT_STYLE.render(result)}"

  result
end


def confirm(question)
  label = PROMPT_STYLE.render(question)
  hint = DEFAULT_STYLE.render(" (y/N):")
  print "#{label}#{hint} #{ansi_color(YELLOW)}"

  answer = $stdin.gets.chomp
  print RESET_COLOR
  result = answer.downcase == "y"

  # Rewrite the line with the final value
  print "#{CURSOR_UP}#{CLEAR_LINE}"
  puts "#{label}#{DEFAULT_STYLE.render(":")} #{INPUT_STYLE.render(result ? "Yes" : "No")}"

  result
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FileUtils.chdir APP_ROOT do
  puts
  header("Rails Project Configuration")
  puts

  if File.exist?(".configured")
    warning("âš ï¸  This project appears to be already configured.")
    puts
    unless confirm("Do you want to reconfigure?")
      puts "Exiting..."
      exit 0
    end
    puts
  end

  directory_name = project_name_from_directory
  suggested_name = to_class_name(directory_name)

  muted("Current directory: #{directory_name}")
  puts

  # â”€â”€ Project Identity â”€â”€

  section("Project Identity")

  project_name = prompt("Project name (CamelCase)", suggested_name)
  project_name = to_class_name(project_name)
  service_name = to_service_name(project_name)

  port = prompt("Development server port", "3000")

  # â”€â”€ Deployment Configuration â”€â”€

  section("Deployment Configuration")

  domain = prompt("App domain (e.g., myapp.example.com)", "app.example.com")

  domain_parts = domain.split(".")
  base_domain = domain_parts.length > 2 ? domain_parts[-2..].join(".") : domain

  admin_email = prompt("Admin email address", "admin@#{base_domain}")

  mailer_from = prompt("Mailer from address", "noreply@#{base_domain}")

  # â”€â”€ Multitenancy â”€â”€

  section("Multitenancy")

  multi_tenant = confirm("Enable multitenancy? (users can create/join multiple teams)")

  # Update initializer file directly
  initializer_path = "config/initializers/multitenancy.rb"
  File.write(initializer_path, "Rails.configuration.x.multi_tenant = #{multi_tenant}\n")
  success("  âœ“ Updated #{initializer_path}")

  # â”€â”€ Apply Configuration â”€â”€

  section("Renaming project from Template to #{project_name}")

  replace_in_file("config/application.rb", "module Template", "module #{project_name}")
  replace_in_file("Rakefile", "Template::Application", "#{project_name}::Application")

  %w[development test production].each do |env|
    replace_in_file("config/environments/#{env}.rb", "Template::Application", "#{project_name}::Application")
  end

  replace_in_file("config.ru", "Template::Application", "#{project_name}::Application")

  if File.exist?("package.json")
    replace_in_file("package.json", '"name": "template"', "\"name\": \"#{directory_name}\"")
  end

  replace_in_file("config/locales/en.yml", "app_name: Template", "app_name: #{project_name}")
  replace_in_file("app/views/pwa/manifest.json.erb", "Template", project_name)
  replace_in_file("public/site.webmanifest", "Template", project_name)

  section("Configuring deploy files")

  replace_in_file("config/deploy.yml", "service: template", "service: #{service_name}")
  replace_in_file("config/deploy.yml", "image: template", "image: #{service_name}")
  replace_in_file("config/deploy.yml", "app.example.com", domain)
  replace_in_file("config/deploy.yml", "template_storage:/rails/storage", "#{service_name}_storage:/rails/storage")

  replace_in_file("config/environments/production.rb", 'host: "app.example.com"', "host: \"#{domain}\"")
  replace_in_file("config/environments/production.rb", '"app.example.com"', "\"#{domain}\"")
  replace_in_file("config/environments/production.rb", '/.*\.example\.com/', "/.*\\.#{Regexp.escape(base_domain).gsub('\\.', '\\.')}/")
  replace_in_file("config/environments/production.rb", 'from: "noreply@app.example.com"', "from: \"#{mailer_from}\"")

  replace_in_file("Dockerfile", "docker build -t template", "docker build -t #{service_name}")
  replace_in_file("Dockerfile", "--name template template", "--name #{service_name} #{service_name}")

  if port != "3000"
    replace_in_file("Procfile.dev", "bin/rails server", "bin/rails server -p #{port}")
    replace_in_file("config/environments/development.rb", "port: 3000", "port: #{port}")
  end

  # Update seeds
  File.write("db/seeds.rb", <<~RUBY)
    # This file should ensure the existence of records required to run the application in every environment (production,
    # development, test). The code here should be idempotent so that it can be executed at any point in every environment.
    # The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).

    # Create first admin
    admin = Admin.find_or_create_by!(email: "#{admin_email}")
    puts "âœ“ Admin created: \#{admin.email}"
  RUBY
  success("  âœ“ Updated db/seeds.rb")

  section("Writing credentials")

  require "active_support/encrypted_configuration"
  FileUtils.mkdir_p("config/credentials")

  %w[development production].each do |env|
    key_path = "config/credentials/#{env}.key"
    credentials_path = "config/credentials/#{env}.yml.enc"

    unless File.exist?(key_path)
      key = ActiveSupport::EncryptedConfiguration.generate_key
      File.write(key_path, key)
      success("  âœ“ Generated #{env} key: #{key_path}")
    end

    credentials_hash = { "secret_key_base" => SecureRandom.hex(64) }

    config = ActiveSupport::EncryptedConfiguration.new(
      config_path: credentials_path,
      key_path: key_path,
      env_key: "RAILS_MASTER_KEY",
      raise_if_missing_key: false
    )

    config.write(YAML.dump(credentials_hash))
    success("  âœ“ #{env.capitalize} credentials updated: #{credentials_path}")
  end

  File.write(".configured", "Configured on #{Time.now}\nProject: #{project_name}\nDomain: #{domain}\nAdmin: #{admin_email}\n")

  # â”€â”€ Git Remote â”€â”€

  section("Configuring git remote")

  # Rename origin to template (keep reference to template repo)
  if system("git remote get-url origin > /dev/null 2>&1")
    system("git remote rename origin template")
    success("  âœ“ Renamed origin to template")
  end

  puts
  muted("Enter your repository URL to set as origin (or press Enter to skip):")
  repo_url = prompt("Repository URL (e.g., git@github.com:user/repo.git)")

  unless repo_url.to_s.empty?
    system("git", "remote", "add", "origin", repo_url)
    success("  âœ“ Set origin to #{repo_url}")
  end

  # Show tip about updating from template
  puts
  tip("ðŸ’¡  TIP: The original template is now available as 'template' remote.")
  tip("   To pull future updates and new features from the template:")
  tip("")
  tip("   git fetch template")
  tip("   git merge template/main")
  puts

  # â”€â”€ Commit â”€â”€

  section("Committing configuration")
  commit_message = <<~MSG
    Configure project: #{project_name}

    Domain: #{domain}
    Admin: #{admin_email}
  MSG
  system("git add -A")
  if system("git", "commit", "-m", commit_message.strip)
    success("  âœ“ Configuration committed")
  else
    muted("  (no changes to commit)")
  end

  puts
  header("âœ“ Configuration Complete!")
  puts
  tip("ðŸ’¡  TIP: Configure API keys (AI, Stripe, SMTP, Litestream) in the admin panel:")
  tip("   /madmin/settings")
  puts
end
