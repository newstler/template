#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "io/console"
require "yaml"
require "securerandom"

APP_ROOT = File.expand_path("..", __dir__)

def system!(*args)
  system(*args, exception: true)
end

def prompt(question, default = nil)
  print question
  print " [#{default}]" if default
  print ": "
  answer = $stdin.gets.chomp
  answer.empty? && default ? default : answer
end

def project_name_from_directory
  File.basename(APP_ROOT)
end

def to_class_name(string)
  string.split(/[-_]/).map(&:capitalize).join
end

def replace_in_file(file_path, old_content, new_content)
  return unless File.exist?(file_path)

  content = File.read(file_path)
  if content.include?(old_content)
    File.write(file_path, content.gsub(old_content, new_content))
    puts "  ✓ Updated #{file_path}"
  end
end

FileUtils.chdir APP_ROOT do
  puts "═" * 60
  puts "  Rails Project Configuration"
  puts "═" * 60
  puts

  # Check if already configured
  if File.exist?(".configured")
    puts "⚠️  This project appears to be already configured."
    print "Do you want to reconfigure? (y/N): "
    answer = $stdin.gets.chomp
    unless answer.downcase == "y"
      puts "Exiting..."
      exit 0
    end
    puts
  end

  # Get project name
  directory_name = project_name_from_directory
  suggested_name = to_class_name(directory_name)

  puts "Current directory: #{directory_name}"
  project_name = prompt("Project name (CamelCase)", suggested_name)
  project_name = to_class_name(project_name) # Ensure proper format

  puts "\n── Renaming project from Template to #{project_name}... ──\n"

  # Update config/application.rb
  replace_in_file(
    "config/application.rb",
    "module Template",
    "module #{project_name}"
  )

  # Update Rakefile
  replace_in_file(
    "Rakefile",
    "Template::Application",
    "#{project_name}::Application"
  )

  # Update config/environments/*.rb
  %w[development test production].each do |env|
    replace_in_file(
      "config/environments/#{env}.rb",
      "Template::Application",
      "#{project_name}::Application"
    )
  end

  # Update config.ru
  replace_in_file(
    "config.ru",
    "Template::Application",
    "#{project_name}::Application"
  )

  # Update bin/rails
  replace_in_file(
    "bin/rails",
    'APP_PATH = File.expand_path("../config/application", __dir__)',
    "APP_PATH = File.expand_path(\"../config/application\", __dir__)"
  )

  # Update package.json if exists
  if File.exist?("package.json")
    replace_in_file(
      "package.json",
      '"name": "template"',
      "\"name\": \"#{directory_name}\""
    )
  end

  puts "\n── Configuring first admin... ──\n"

  admin_email = prompt("Admin email address", "admin@example.com")

  puts "\n── Configuring AI API Keys (optional)... ──\n"
  puts "RubyLLM supports OpenAI and Anthropic (Claude) APIs."
  puts "Press Enter to skip if you want to configure them later.\n"

  openai_api_key = prompt("OpenAI API Key")
  anthropic_api_key = prompt("Anthropic (Claude) API Key")

  puts "\n── Configuring Litestream (optional)... ──\n"
  puts "Litestream provides SQLite replication to S3-compatible storage."
  puts "Press Enter to skip if you don't need it yet.\n"

  replica_bucket = prompt("S3 bucket name (e.g., my-app-backups)")
  replica_key_id = prompt("S3 Access Key ID") unless replica_bucket.empty?
  replica_access_key = prompt("S3 Secret Access Key") unless replica_bucket.empty?

  # Store config temporarily
  config_data = {
    "admin_email" => admin_email,
    "openai_api_key" => openai_api_key,
    "anthropic_api_key" => anthropic_api_key,
    "replica_bucket" => replica_bucket,
    "replica_key_id" => replica_key_id,
    "replica_access_key" => replica_access_key
  }
  File.write(".configure_temp.yml", YAML.dump(config_data))

  # Update seeds file with admin email
  seeds_content = <<~RUBY
    # This file should ensure the existence of records required to run the application in every environment (production,
    # development, test). The code here should be idempotent so that it can be executed at any point in every environment.
    # The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).

    # Create first admin
    admin = Admin.find_or_create_by!(email: "#{admin_email}")
    puts "✓ Admin created: \#{admin.email}"
  RUBY

  File.write("db/seeds.rb", seeds_content)
  puts "  ✓ Updated db/seeds.rb"

  puts "\n── Writing credentials... ──\n"

  # Load config data
  config_data = YAML.load_file(".configure_temp.yml")

  # Build credentials YAML content
  has_ai_keys = !config_data["openai_api_key"].to_s.empty? || !config_data["anthropic_api_key"].to_s.empty?
  has_litestream = !config_data["replica_bucket"].to_s.empty?

  if has_ai_keys || has_litestream
    # Build credentials hash
    credentials_hash = {}

    # Add AI credentials if provided
    if has_ai_keys
      credentials_hash["openai"] = { "api_key" => config_data["openai_api_key"] } unless config_data["openai_api_key"].to_s.empty?
      credentials_hash["anthropic"] = { "api_key" => config_data["anthropic_api_key"] } unless config_data["anthropic_api_key"].to_s.empty?
    end

    # Add Litestream credentials if provided
    if has_litestream
      credentials_hash["litestream"] = {
        "replica_bucket" => config_data["replica_bucket"],
        "replica_key_id" => config_data["replica_key_id"],
        "replica_access_key" => config_data["replica_access_key"]
      }
    end

    # Write directly to development credentials
    require "active_support/encrypted_configuration"

    # Create credentials directory if it doesn't exist
    FileUtils.mkdir_p("config/credentials")

    # Initialize development credentials
    key_path = "config/credentials/development.key"
    credentials_path = "config/credentials/development.yml.enc"

    # Generate key if it doesn't exist
    unless File.exist?(key_path)
      key = ActiveSupport::EncryptedConfiguration.generate_key
      File.write(key_path, key)
      puts "  ✓ Generated development key: #{key_path}"
    end

    # Write the credentials
    config = ActiveSupport::EncryptedConfiguration.new(
      config_path: credentials_path,
      key_path: key_path,
      env_key: "RAILS_MASTER_KEY",
      raise_if_missing_key: false
    )

    config.write(YAML.dump(credentials_hash))

    puts "  ✓ Development credentials updated"
    puts "  ✓ Saved to: #{credentials_path}"
    puts "  ✓ Key saved to: #{key_path}"
  else
    puts "  ⊝ No credentials to write (no API keys or Litestream configured)"
  end

  # Clean up temp files
  File.delete(".configure_temp.yml") if File.exist?(".configure_temp.yml")

  # Mark as configured
  File.write(".configured", "Configured on #{Time.now}\nProject: #{project_name}\nAdmin: #{admin_email}\n")

  puts "\n" + "═" * 60
  puts "  ✓ Configuration Complete!"
  puts "═" * 60
  puts
  puts "Project: #{project_name}"
  puts "Admin: #{admin_email}"
  puts
  puts "Running bin/setup to install dependencies and setup database..."
  puts

  # Run bin/setup (after credentials are written)
  system!("bin/setup")

  puts "\n" + "═" * 60
  puts "  ✓ All Done!"
  puts "═" * 60
  puts
  puts "Next steps:"
  puts "  1. Run: bin/dev"
  puts "  2. Visit: /admins/session/new"
  puts "  3. Request magic link for: #{admin_email}"
  puts "  4. Check your email and click the magic link"
  puts "  5. Access Madmin admin panel at: /madmin"
  puts
end
