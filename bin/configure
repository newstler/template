#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "yaml"
require "securerandom"

APP_ROOT = File.expand_path("..", __dir__)

# Install lipgloss if not available
begin
  require "lipgloss"
rescue LoadError
  puts "Installing lipgloss gem for terminal styling..."
  system("gem install lipgloss --no-document") || abort("Failed to install lipgloss gem")
  Gem.clear_paths
  require "lipgloss"
end

def system!(*args)
  system(*args, exception: true)
end

def project_name_from_directory
  File.basename(APP_ROOT)
end

# Converts to Ruby module name for config/application.rb
# "my_project" -> "MyProject", "template" -> "Template", "MyApp" -> "MyApp"
def to_class_name(string)
  return string if string.nil? || string.empty?
  return string.split(/[-_]/).map(&:capitalize).join if string.match?(/[-_]/)

  string[0].upcase + string[1..].to_s
end

# Converts to kebab-case for Docker service names, S3 buckets, etc.
# "ProjectName" -> "project-name"
def to_service_name(string)
  string.gsub(/([A-Z])/, '-\1').downcase.sub(/^-/, "").gsub(/[^a-z0-9-]/, "-")
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Styles
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VIOLET = "#7D56F4"
PURPLE = "#874BFD"
GREEN = "#04B575"
MUTED = "#626262"
WHITE = "#FAFAFA"
ORANGE = "#FF9F1C"
CYAN = "#00D9FF"
HOTPINK = "#FF1493"
GOLD = "#FFD700"
YELLOW = "#FFFF00"

HEADER_STYLE = Lipgloss::Style.new
  .border(:rounded)
  .border_foreground(VIOLET)
  .padding_top(1)
  .padding_bottom(1)
  .padding_left(4)
  .padding_right(4)
  .bold(true)
  .foreground(WHITE)

SECTION_STYLE = Lipgloss::Style.new
  .foreground(PURPLE)
  .bold(true)
  .margin_top(1)
  .margin_bottom(1)

SUCCESS_STYLE = Lipgloss::Style.new
  .foreground(GREEN)

MUTED_STYLE = Lipgloss::Style.new
  .foreground(MUTED)
  .italic(true)

SUMMARY_STYLE = Lipgloss::Style.new
  .border(:rounded)
  .border_foreground(GREEN)
  .padding_top(1)
  .padding_bottom(1)
  .padding_left(2)
  .padding_right(2)

WARNING_STYLE = Lipgloss::Style.new
  .foreground(ORANGE)
  .bold(true)

PROMPT_STYLE = Lipgloss::Style.new
  .foreground(CYAN)
  .bold(true)

DEFAULT_STYLE = Lipgloss::Style.new
  .foreground(MUTED)

INPUT_STYLE = Lipgloss::Style.new
  .foreground(GOLD)

TIP_STYLE = Lipgloss::Style.new
  .foreground(HOTPINK)
  .bold(true)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Output helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def header(text) = puts HEADER_STYLE.render(text)
def section(text) = puts SECTION_STYLE.render("â”€â”€ #{text} â”€â”€")
def success(text) = puts SUCCESS_STYLE.render(text)
def muted(text) = puts MUTED_STYLE.render(text)
def warning(text) = puts WARNING_STYLE.render(text)
def summary(text) = puts SUMMARY_STYLE.render(text)
def tip(text) = puts TIP_STYLE.render(text)

def replace_in_file(file_path, old_content, new_content)
  return unless File.exist?(file_path)

  content = File.read(file_path)
  if content.include?(old_content)
    File.write(file_path, content.gsub(old_content, new_content))
    success("  âœ“ Updated #{file_path}")
  end
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Prompts
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# ANSI escape codes for cursor control
CURSOR_UP = "\e[1A"
CLEAR_LINE = "\e[2K"
RESET_COLOR = "\e[0m"

# Convert hex color to ANSI true color escape sequence
def ansi_color(hex)
  hex = hex.delete("#")
  r = hex[0..1].to_i(16)
  g = hex[2..3].to_i(16)
  b = hex[4..5].to_i(16)
  "\e[38;2;#{r};#{g};#{b}m"
end

def prompt(question, default = nil)
  label = PROMPT_STYLE.render(question)
  colon = DEFAULT_STYLE.render(":")

  if default
    default_hint = DEFAULT_STYLE.render(" [#{default}]")
    print "#{label}#{default_hint}#{colon} #{ansi_color(YELLOW)}"
  else
    print "#{label}#{colon} #{ansi_color(YELLOW)}"
  end

  answer = $stdin.gets.chomp
  print RESET_COLOR
  result = answer.empty? && default ? default : answer

  # Rewrite the line with the final value
  print "#{CURSOR_UP}#{CLEAR_LINE}"
  puts "#{label}#{colon} #{INPUT_STYLE.render(result)}"

  result
end


def confirm(question)
  label = PROMPT_STYLE.render(question)
  hint = DEFAULT_STYLE.render(" (y/N):")
  print "#{label}#{hint} #{ansi_color(YELLOW)}"

  answer = $stdin.gets.chomp
  print RESET_COLOR
  result = answer.downcase == "y"

  # Rewrite the line with the final value
  print "#{CURSOR_UP}#{CLEAR_LINE}"
  puts "#{label}#{DEFAULT_STYLE.render(":")} #{INPUT_STYLE.render(result ? "Yes" : "No")}"

  result
end

def secret_prompt(question, default = nil)
  label = PROMPT_STYLE.render(question)
  colon = DEFAULT_STYLE.render(":")

  if default
    default_hint = DEFAULT_STYLE.render(" [#{default}]")
    print "#{label}#{default_hint}#{colon} #{ansi_color(YELLOW)}"
  else
    print "#{label}#{colon} #{ansi_color(YELLOW)}"
  end

  answer = $stdin.gets.chomp
  print RESET_COLOR
  result = answer.empty? && default ? default : answer

  # Rewrite the line with stars instead of the actual value
  print "#{CURSOR_UP}#{CLEAR_LINE}"
  display_value = result.empty? ? "" : "*" * result.length
  puts "#{label}#{colon} #{INPUT_STYLE.render(display_value)}"

  result
end

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FileUtils.chdir APP_ROOT do
  puts
  header("Rails Project Configuration")
  puts

  if File.exist?(".configured")
    warning("âš ï¸  This project appears to be already configured.")
    puts
    unless confirm("Do you want to reconfigure?")
      puts "Exiting..."
      exit 0
    end
    puts
  end

  directory_name = project_name_from_directory
  suggested_name = to_class_name(directory_name)

  muted("Current directory: #{directory_name}")
  puts

  # â”€â”€ Project Identity â”€â”€

  section("Project Identity")

  project_name = prompt("Project name (CamelCase)", suggested_name)
  project_name = to_class_name(project_name)
  service_name = to_service_name(project_name)

  port = prompt("Development server port", "3000")

  # â”€â”€ Deployment Configuration â”€â”€

  section("Deployment Configuration")

  domain = prompt("App domain (e.g., myapp.example.com)", "app.example.com")

  domain_parts = domain.split(".")
  base_domain = domain_parts.length > 2 ? domain_parts[-2..].join(".") : domain

  admin_email = prompt("Admin email address", "admin@#{base_domain}")

  # â”€â”€ SMTP Configuration â”€â”€

  section("SMTP Production Configuration (optional)")
  muted("Press Enter to skip if you want to configure later.")
  puts

  smtp_address = prompt("SMTP server (e.g., smtp.postmarkapp.com)")
  smtp_username = ""
  smtp_password = ""
  unless smtp_address.to_s.empty?
    smtp_username = prompt("SMTP username")
    smtp_password = secret_prompt("SMTP password")
  end

  mailer_from = prompt("Mailer from address", "noreply@#{base_domain}")

  # â”€â”€ Multitenancy â”€â”€

  section("Multitenancy")

  multi_tenant = confirm("Enable multitenancy? (users can create/join multiple teams)")

  # Update initializer file directly
  initializer_path = "config/initializers/multitenancy.rb"
  File.write(initializer_path, "Rails.configuration.x.multi_tenant = #{multi_tenant}\n")
  success("  âœ“ Updated #{initializer_path}")

  # â”€â”€ AI API Keys â”€â”€
  # TODO: RubyLLM supports many providers (OpenAI, Anthropic, Gemini, DeepSeek, etc.)
  # Allow user to select which providers to configure instead of hardcoding OpenAI/Anthropic.

  section("AI API Keys (optional)")
  muted("RubyLLM supports many AI providers. Here you can configure OpenAI and Anthropic.")
  muted("For other providers, add their credentials manually: rails credentials:edit --environment development/production")
  muted("You can use different keys for development and production.")
  puts

  muted("Development keys:")
  openai_api_key_dev = secret_prompt("OpenAI API Key (development)")
  anthropic_api_key_dev = secret_prompt("Anthropic API Key (development)")

  puts
  muted("Production keys (leave blank to use same as development):")
  openai_api_key_prod = secret_prompt("OpenAI API Key (production)")
  anthropic_api_key_prod = secret_prompt("Anthropic API Key (production)")

  # Fall back to dev keys if prod keys are empty
  openai_api_key_prod = openai_api_key_dev if openai_api_key_prod.to_s.empty?
  anthropic_api_key_prod = anthropic_api_key_dev if anthropic_api_key_prod.to_s.empty?

  # â”€â”€ Stripe â”€â”€

  section("Stripe (optional)")
  muted("Stripe handles team billing and subscriptions.")
  muted("Press Enter to skip if you want to configure later.")
  puts

  muted("Development keys:")
  stripe_secret_key_dev = secret_prompt("Stripe Secret Key (development)")
  stripe_publishable_key_dev = ""
  stripe_webhook_secret_dev = ""
  unless stripe_secret_key_dev.to_s.empty?
    stripe_publishable_key_dev = secret_prompt("Stripe Publishable Key (development)")
    stripe_webhook_secret_dev = secret_prompt("Stripe Webhook Secret (development)")
  end

  puts
  muted("Production keys (leave blank to use same as development):")
  stripe_secret_key_prod = secret_prompt("Stripe Secret Key (production)")
  stripe_publishable_key_prod = ""
  stripe_webhook_secret_prod = ""
  unless stripe_secret_key_prod.to_s.empty?
    stripe_publishable_key_prod = secret_prompt("Stripe Publishable Key (production)")
    stripe_webhook_secret_prod = secret_prompt("Stripe Webhook Secret (production)")
  end

  # Fall back to dev keys if prod keys are empty
  stripe_secret_key_prod = stripe_secret_key_dev if stripe_secret_key_prod.to_s.empty?
  stripe_publishable_key_prod = stripe_publishable_key_dev if stripe_publishable_key_prod.to_s.empty?
  stripe_webhook_secret_prod = stripe_webhook_secret_dev if stripe_webhook_secret_prod.to_s.empty?

  # â”€â”€ Litestream Configuration â”€â”€

  section("Litestream Configuration (optional)")
  muted("Litestream provides SQLite replication to S3-compatible storage.")
  muted("Press Enter to skip if you don't need it yet.")
  puts

  replica_bucket = prompt("S3 bucket name")
  replica_key_id = ""
  replica_access_key = ""

  unless replica_bucket.to_s.empty?
    replica_key_id = secret_prompt("S3 Access Key ID")
    replica_access_key = secret_prompt("S3 Secret Access Key")
  end

  # â”€â”€ Apply Configuration â”€â”€

  section("Renaming project from Template to #{project_name}")

  replace_in_file("config/application.rb", "module Template", "module #{project_name}")
  replace_in_file("Rakefile", "Template::Application", "#{project_name}::Application")

  %w[development test production].each do |env|
    replace_in_file("config/environments/#{env}.rb", "Template::Application", "#{project_name}::Application")
  end

  replace_in_file("config.ru", "Template::Application", "#{project_name}::Application")

  if File.exist?("package.json")
    replace_in_file("package.json", '"name": "template"', "\"name\": \"#{directory_name}\"")
  end

  replace_in_file("config/locales/en.yml", "app_name: Template", "app_name: #{project_name}")
  replace_in_file("app/views/pwa/manifest.json.erb", "Template", project_name)
  replace_in_file("public/site.webmanifest", "Template", project_name)

  section("Configuring deploy files")

  replace_in_file("config/deploy.yml", "service: template", "service: #{service_name}")
  replace_in_file("config/deploy.yml", "image: template", "image: #{service_name}")
  replace_in_file("config/deploy.yml", "app.example.com", domain)
  replace_in_file("config/deploy.yml", "template_storage:/rails/storage", "#{service_name}_storage:/rails/storage")

  replace_in_file("config/environments/production.rb", 'host: "app.example.com"', "host: \"#{domain}\"")
  replace_in_file("config/environments/production.rb", '"app.example.com"', "\"#{domain}\"")
  replace_in_file("config/environments/production.rb", '/.*\.example\.com/', "/.*\\.#{Regexp.escape(base_domain).gsub('\\.', '\\.')}/")
  replace_in_file("config/environments/production.rb", 'from: "noreply@app.example.com"', "from: \"#{mailer_from}\"")

  replace_in_file("Dockerfile", "docker build -t template", "docker build -t #{service_name}")
  replace_in_file("Dockerfile", "--name template template", "--name #{service_name} #{service_name}")

  if port != "3000"
    replace_in_file("Procfile.dev", "bin/rails server", "bin/rails server -p #{port}")
    replace_in_file("config/environments/development.rb", "port: 3000", "port: #{port}")
  end

  # Store config temporarily
  config_data = {
    "admin_email" => admin_email,
    "smtp_address" => smtp_address,
    "smtp_username" => smtp_username,
    "smtp_password" => smtp_password,
    "openai_api_key_dev" => openai_api_key_dev,
    "anthropic_api_key_dev" => anthropic_api_key_dev,
    "openai_api_key_prod" => openai_api_key_prod,
    "anthropic_api_key_prod" => anthropic_api_key_prod,
    "stripe_secret_key_dev" => stripe_secret_key_dev,
    "stripe_publishable_key_dev" => stripe_publishable_key_dev,
    "stripe_webhook_secret_dev" => stripe_webhook_secret_dev,
    "stripe_secret_key_prod" => stripe_secret_key_prod,
    "stripe_publishable_key_prod" => stripe_publishable_key_prod,
    "stripe_webhook_secret_prod" => stripe_webhook_secret_prod,
    "replica_bucket" => replica_bucket,
    "replica_key_id" => replica_key_id,
    "replica_access_key" => replica_access_key
  }
  File.write(".configure_temp.yml", YAML.dump(config_data))

  # Update seeds
  File.write("db/seeds.rb", <<~RUBY)
    # This file should ensure the existence of records required to run the application in every environment (production,
    # development, test). The code here should be idempotent so that it can be executed at any point in every environment.
    # The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).

    # Create first admin
    admin = Admin.find_or_create_by!(email: "#{admin_email}")
    puts "âœ“ Admin created: \#{admin.email}"
  RUBY
  success("  âœ“ Updated db/seeds.rb")

  section("Writing credentials")

  config_data = YAML.load_file(".configure_temp.yml")

  # Development credentials: secret_key_base + AI keys only
  dev_credentials = {
    "secret_key_base" => SecureRandom.hex(64)
  }
  dev_credentials["openai"] = { "api_key" => config_data["openai_api_key_dev"] } unless config_data["openai_api_key_dev"].to_s.empty?
  dev_credentials["anthropic"] = { "api_key" => config_data["anthropic_api_key_dev"] } unless config_data["anthropic_api_key_dev"].to_s.empty?
  unless config_data["stripe_secret_key_dev"].to_s.empty?
    dev_credentials["stripe"] = {
      "secret_key" => config_data["stripe_secret_key_dev"],
      "publishable_key" => config_data["stripe_publishable_key_dev"],
      "webhook_secret" => config_data["stripe_webhook_secret_dev"]
    }
  end

  # Production credentials: secret_key_base + AI keys + Stripe + SMTP + Litestream
  prod_credentials = {
    "secret_key_base" => SecureRandom.hex(64)
  }
  prod_credentials["openai"] = { "api_key" => config_data["openai_api_key_prod"] } unless config_data["openai_api_key_prod"].to_s.empty?
  prod_credentials["anthropic"] = { "api_key" => config_data["anthropic_api_key_prod"] } unless config_data["anthropic_api_key_prod"].to_s.empty?
  unless config_data["stripe_secret_key_prod"].to_s.empty?
    prod_credentials["stripe"] = {
      "secret_key" => config_data["stripe_secret_key_prod"],
      "publishable_key" => config_data["stripe_publishable_key_prod"],
      "webhook_secret" => config_data["stripe_webhook_secret_prod"]
    }
  end

  if !config_data["smtp_address"].to_s.empty?
    prod_credentials["smtp"] = {
      "address" => config_data["smtp_address"],
      "username" => config_data["smtp_username"],
      "password" => config_data["smtp_password"]
    }
  end

  if !config_data["replica_bucket"].to_s.empty? && !config_data["replica_key_id"].to_s.empty?
    prod_credentials["litestream"] = {
      "replica_bucket" => config_data["replica_bucket"],
      "replica_key_id" => config_data["replica_key_id"],
      "replica_access_key" => config_data["replica_access_key"]
    }
  end

  require "active_support/encrypted_configuration"
  FileUtils.mkdir_p("config/credentials")

  { "development" => dev_credentials, "production" => prod_credentials }.each do |env, credentials_hash|
    key_path = "config/credentials/#{env}.key"
    credentials_path = "config/credentials/#{env}.yml.enc"

    unless File.exist?(key_path)
      key = ActiveSupport::EncryptedConfiguration.generate_key
      File.write(key_path, key)
      success("  âœ“ Generated #{env} key: #{key_path}")
    end

    config = ActiveSupport::EncryptedConfiguration.new(
      config_path: credentials_path,
      key_path: key_path,
      env_key: "RAILS_MASTER_KEY",
      raise_if_missing_key: false
    )

    config.write(YAML.dump(credentials_hash))
    success("  âœ“ #{env.capitalize} credentials updated: #{credentials_path}")
  end

  File.delete(".configure_temp.yml") if File.exist?(".configure_temp.yml")
  File.write(".configured", "Configured on #{Time.now}\nProject: #{project_name}\nDomain: #{domain}\nAdmin: #{admin_email}\n")

  # â”€â”€ Git Remote â”€â”€

  section("Configuring git remote")

  # Rename origin to template (keep reference to template repo)
  if system("git remote get-url origin > /dev/null 2>&1")
    system("git remote rename origin template")
    success("  âœ“ Renamed origin to template")
  end

  puts
  muted("Enter your repository URL to set as origin (or press Enter to skip):")
  repo_url = prompt("Repository URL (e.g., git@github.com:user/repo.git)")

  unless repo_url.to_s.empty?
    system("git", "remote", "add", "origin", repo_url)
    success("  âœ“ Set origin to #{repo_url}")
  end

  # Show tip about updating from template
  puts
  tip("ðŸ’¡  TIP: The original template is now available as 'template' remote.")
  tip("   To pull future updates and new features from the template:")
  tip("")
  tip("   git fetch template")
  tip("   git merge template/main")
  puts

  # â”€â”€ Commit â”€â”€

  section("Committing configuration")
  commit_message = <<~MSG
    Configure project: #{project_name}

    Domain: #{domain}
    Admin: #{admin_email}
  MSG
  system("git add -A")
  if system("git", "commit", "-m", commit_message.strip)
    success("  âœ“ Configuration committed")
  else
    muted("  (no changes to commit)")
  end

  puts
  header("âœ“ Configuration Complete!")
  puts
end
